
//////////////////////////////////////  CONEXION SERIAL ////////////////////////
void debug_putc(char c) {
    SB_REG = c;           // Carga el carácter
    SC_REG = 0x81;        // Inicia transmisión (Start + Internal Clock)
    while (SC_REG & 0x80); // Espera a que termine
}

// Envía cadena terminada en 0
void debug_print(const char* s) {
    while (*s) debug_putc(*s++);
}

//////////////////////////////////////  CONEXION SERIAL ////////////////////////

void numberToTilesXY(UINT16 value, unsigned char* dest, UINT8 digits) {
    for (INT8 i = digits - 1; i >= 0; i--) {
        dest[i] = (value % 10) + 1;
        value /= 10;
    }
}

unsigned char hud_line[20] = {
0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,            
0x00,0x00};
numberToTilesXY(tile_world_x, &hud_line[2], 3);
numberToTilesXY(tile_world_y, &hud_line[6], 3);
numberToTilesXY(TP, &hud_line[10], 1);
numberToTilesXY(TL, &hud_line[12], 1);
numberToTilesXY(TR, &hud_line[14], 1);
numberToTilesXY(BL, &hud_line[16], 1);
numberToTilesXY(BR, &hud_line[18], 1);
set_win_tiles(0, 0, 20, 1, hud_line);


UINT8 get_tile_at_world(UINT16 world_x, UINT16 world_y) {
    // fuera de límites = sólido

    UINT16 wx = world_x / TILE;
    UINT16 wy = world_y / TILE;

    if (wx < 0 || wy < 0 || wx >= 200 || wy >= 18) {
        return 0xFF;
    }

    return background[wy * MAP_W_T + wx];
}


BYTE is_solid(UINT8 tile) {
    if(tile == 0xFF) return TRUE;   // fuera = sólido
    return (tile != 0x00);         
}




UBYTE player_collides(UINT16 world_x, UINT16 world_y) {
    //const UINT8 inset = 1;

    UINT16 tile_world_x = world_x/TILE;
    UINT16 tile_world_y = world_y/TILE;


    unsigned char hud_line[20] = {
    0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,            
    0x00,0x00};
    numberToTilesXY(tile_world_x, &hud_line[2], 3);
    numberToTilesXY(tile_world_y, &hud_line[6], 3);
    debug_print(hud_line);

    const UINT8 inset = 1;
    UINT16 left   = world_x + inset;
    UINT16 right  = world_x + 16 - inset;
    UINT16 top    = world_y + inset;
    UINT16 bottom = world_y + 16 - inset;

    UINT8 TP = get_tile_at_world(tile_world_x, tile_world_y);
    UINT8 TL = get_tile_at_world(left, top);
    UINT8 TR = get_tile_at_world(right, top);
    UINT8 BL = get_tile_at_world(left, bottom);
    UINT8 BR = get_tile_at_world(right, bottom);

    numberToTilesXY(TP, &hud_line[10], 1);
    numberToTilesXY(TL, &hud_line[12], 1);
    numberToTilesXY(TR, &hud_line[14], 1);
    numberToTilesXY(BL, &hud_line[16], 1);
    numberToTilesXY(BR, &hud_line[18], 1);

    set_win_tiles(0, 0, 20, 1, hud_line);

    return FALSE;


    /*
    return (is_solid(TL) || is_solid(TR) || is_solid(BL) || is_solid(BR));
    */
}
